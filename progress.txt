## Progress Tracker

### Phase 1: Type Safety & Foundations
- [x] Task 1: Remove branded ID types (removed Brand<T,B> utility type and all 16 branded ID type exports from helpers.ts, reverted createId() to return plain string, removed .$type<>() annotations from all 9 schema files, removed branded ID imports/casts from 12 API module files and 4 AI package files — 25+ files changed, zero branded types remaining)
- [x] Task 2: Type-safe environment validation (created @milkpod/env package with Zod schemas: serverEnv() validates DATABASE_URL, BETTER_AUTH_SECRET, BETTER_AUTH_URL, CORS_ORIGIN, NODE_ENV, GOOGLE_CLIENT_ID, GOOGLE_CLIENT_SECRET, ELEVENLABS_API_KEY; clientEnv() validates NEXT_PUBLIC_SERVER_URL with default. Replaced all direct process.env access in packages/db/src/index.ts, packages/auth/src/index.ts, apps/server/src/index.ts, packages/api/src/modules/ingest/elevenlabs.ts, apps/web/src/lib/api.ts, apps/web/src/lib/auth/client.ts, apps/web/src/hooks/use-milkpod-chat.ts, apps/web/src/hooks/use-shared-chat.ts, apps/web/src/hooks/use-asset-events.ts. Updated .env.example with all required vars including Google OAuth and ElevenLabs. drizzle.config.ts left with process.env since it's a CLI tool config.)
- [x] Task 3: Shared API response types
- [x] Task 4: Replace t.Any() message validation
- [x] Task 5: Shared tool output types
- [x] Task 6: Discriminated union for asset status (included in Task 3)

### Phase 2: Critical Fixes
- [x] Task 7: Fix convertToModelMessages async (already awaited in stream.ts)
- [x] Task 8: Wire assetId/collectionId into chat context
- [x] Task 9: Resource authorization
- [x] Task 10: Handle reasoning tokens (Option A: collapsible Thinking section in message.tsx + sendReasoning: true)
- [x] Task 11: Input guardrails (gpt-4o-mini pre-check in guardrails.ts, static refusal via createUIMessageStream)

### Phase 3: Data & Persistence
- [x] Task 12: Normalize message persistence (qa_message_parts table, saveMessages/getMessages in ChatService, migration 0002)
- [x] Task 13: Embedding model versioning (added model + dimensions columns to embeddings table, constants in provider.ts, pipeline stores model info, retrieval warns on mismatch, migration 0003)
- [x] Task 14: Pipeline error handling & retry (withRetry utility with exponential backoff + jitter, 3 retries per stage, attempts/lastError tracked in DB, POST /api/assets/:id/retry endpoint, retry button in asset-card.tsx)

### Phase 4: UX Improvements
- [x] Task 15: Asset detail view (new /asset/[id] route with DashboardLayout, AssetDetail client component fetches asset+transcript+segments via Eden, TranscriptViewer shows timestamped segments with speaker labels, ChatPanel reused as side panel, status polling while processing, back nav to library. Asset cards now link to detail page when ready.)
- [x] Task 16: Collection management UI (library tab Assets/Collections toggle, collection-list.tsx + collection-card.tsx with edit/delete dialogs, create-collection-dialog.tsx, add-to-collection-dialog.tsx on asset cards via FolderPlus icon, /collection/[id] detail page with member asset list + remove items + scoped Q&A ChatPanel via collectionId, add-asset-to-collection-dialog.tsx in detail view)
- [x] Task 17: Streaming progress indicators (enhanced existing SSE system: added progress field to AssetStatusEvent, emitAssetProgress helper for sub-stage progress, pipeline emits per-segment embedding progress, AssetCard uses real SSE progress mapped to overall % via stage ranges, useAssetEvents hook has auto-reconnection with exponential backoff, AssetList tracks per-asset progress map, AssetDetail shows live progress messages)
- [x] Task 18: Search and filter (API: GET /api/assets?q=&status=&sourceType= with ilike title/channelName search + inArray status/sourceType filtering in AssetService.search(), Frontend: SearchFilterBar component with debounced search input + status/sourceType Select dropdowns + clear filters, wired into LibraryTab → AssetList)

### Phase 5: Sharing & Access Control
- [x] Task 19: Share link schema & API (share_links table with id/token/userId/assetId/collectionId/canQuery/expiresAt/revokedAt, ShareService with create/list/revoke/validateToken/getSharedResource, shares module with POST /api/shares, GET /api/shares, DELETE /api/shares/:id, GET /api/shares/validate/:token, crypto-random 32-char base64url tokens, ownership verification on create, expiry+revocation checks on validate, migration 0004)
- [x] Task 20: Share link UI (ShareDialog component with create link form: canQuery toggle, expiry selector, auto-copy to clipboard; lists existing active links with copy + revoke buttons; added to asset-detail.tsx and collection-detail.tsx header areas; public /share/[token] page with SharedView component that validates token via API and renders read-only transcript viewer for assets or item list for collections; enhanced ShareService.getSharedResource to load transcript+segments for assets and items for collections; rebuilt @milkpod/api dist to include shares module types)
- [x] Task 21: Rate-limited shared Q&A (already implemented in Task 20: POST /api/shares/chat/:token public endpoint with token validation, ShareService.checkRateLimit 10 queries/hour per share link, shareQueries table for audit logging, SharedChatPanel with rate limit warnings, useSharedChat hook with X-RateLimit-Remaining header extraction)

### Phase 6: Production Hardening
- [x] Task 22: Request logging middleware (packages/api/src/middleware/logger.ts: Elysia plugin with onRequest/onAfterResponse hooks, WeakMap-based request timing, structured JSON logs with level/method/path/status/durationMs/userId/timestamp, health check noise skipped, wired into packages/api/src/index.ts as first plugin)
- [x] Task 23: Rate limiting (packages/api/src/middleware/rate-limit.ts: in-memory token bucket per user per endpoint category, 3 tiers — ingest: 10/min, chat: 30/min, CRUD: 100/min, 429 with Retry-After header, falls back to IP for unauthenticated endpoints, periodic bucket cleanup for idle entries, wired into main app after session derive)
- [x] Task 24: Health checks & graceful shutdown (upgraded /health to check DB connectivity via `db.execute(sql\`SELECT 1\`)` returning JSON {status, db}, added /ready endpoint with extensible checks object returning 503 on failure, moved health+ready before auth derive so they don't require session, exported closeConnections() from @milkpod/api, graceful shutdown in apps/server via SIGTERM/SIGINT handlers that call server.stop() then closeConnections(), logger skips /ready noise)
- [x] Task 25: Error boundaries & offline handling (global-error.tsx for root-level crashes, error.tsx at root/dashboard/asset/collection/share routes with contextual messages + retry buttons + nav links, not-found.tsx for 404s, OfflineBanner component with online/offline event listeners showing fixed banner when disconnected, wired into Providers)

### Phase 7: Podcast Features
- [x] Task 26: Podcast feed schema (5 new tables: podcast_feeds with RSS metadata + refresh cadence + user FK, podcast_episodes with feed FK + optional media_asset FK + extended episode_status enum [queued/fetching/transcribing/labeling/editing/publishing/ready/failed] + attempts/lastError, episode_edits with EDL segments [keep/skip/mute actions + label/reason], episode_renders with render status + storage key + format/size metadata, filter_rules with user-scoped topic preferences [skip/mute actions + optional feed scoping + priority]. 4 enums: episode_status, edit_action, render_status, filter_action. Indexes on feedId, episodeId, userId, compound guid+feedId. Migration 0006.)
- [x] Task 27: RSS ingestion (Elysia podcasts module with full route set: POST /api/podcasts/feeds to add feed + parse RSS + discover episodes, GET /api/podcasts/feeds to list, GET /api/podcasts/feeds/:id to get, PATCH /api/podcasts/feeds/:id to update refresh interval, DELETE /api/podcasts/feeds/:id to remove, POST /api/podcasts/feeds/:id/refresh to re-fetch RSS + discover new episodes, GET /api/podcasts/feeds/:id/episodes to list episodes, GET /api/podcasts/episodes/:id to get episode, POST /api/podcasts/episodes/:id/ingest to trigger transcription pipeline for single episode, POST /api/podcasts/feeds/:id/ingest to batch-ingest all queued episodes. Episode pipeline in episode-pipeline.ts: creates media_asset with sourceType 'podcast' + mediaType 'audio', links episode→asset, skips yt-dlp since podcast sourceUrl is direct audio from RSS enclosure, transcribes via ElevenLabs, generates embeddings, tracks episode status alongside asset status, exponential backoff+jitter retry with 3 attempts. Mounted podcasts module in main API app. Fixed unused mediaAssets import in service.ts.)
