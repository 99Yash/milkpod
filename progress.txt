# Audit Fix Progress

## Task 1: Add missing database indexes (DB-1) ✅
**Files changed**: `packages/db/src/schema/collections.ts`, `packages/db/src/schema/qa.ts`, `packages/db/src/schema/share-queries.ts`, `packages/db/src/schema/media-assets.ts`, `packages/db/src/schema/transcript-segments.ts`
**Migration**: `packages/db/src/migrations/0013_warm_starjammers.sql`
**Outcome**: Added 7 missing indexes — `collection_item_collection_id_idx`, `collection_item_asset_id_idx`, `qa_evidence_message_id_idx`, `qa_evidence_segment_id_idx`, `share_query_link_created_idx`, `media_asset_user_status_idx`, `transcript_segment_transcript_index_idx`. Migration generated and applied. Type checks pass.

## Task 2: Fix guardrails to fail closed (SEC-1) ✅
**Files changed**: `packages/ai/src/guardrails.ts`
**Outcome**: Changed catch block from fail-open (`{ allowed: true }`) to fail-closed with heuristic fallback. Added `heuristicCheck()` function that: (1) denies messages over 2000 chars, (2) denies messages matching 7 jailbreak/prompt-injection patterns (e.g. "ignore previous instructions", "you are now a", "system prompt", "DAN"), (3) allows everything else. Added optional `reason` field to `GuardrailResult` interface. The caller in `stream.ts` already handles denials correctly — no changes needed there. Type checks pass.

## Task 3: Add timeout to AI streaming requests (SEC-3) ✅
**Files changed**: `packages/ai/src/stream.ts`
**Outcome**: Added `timeout: { totalMs: 120_000, chunkMs: 30_000 }` to the `streamText()` call — uses AI SDK v6's built-in timeout support instead of a manual AbortController. `totalMs` caps the entire multi-step stream at 2 minutes; `chunkMs` detects a hung provider if no data arrives for 30 seconds. Added `AbortError` handling to `toUIMessageStreamResponse.onError` — returns "Response timed out. Please try again." to the user. Type checks pass.

## Task 4: Switch rate limiter to user-based with IP fallback (SEC-4) ✅
**Files changed**: `packages/api/src/middleware/rate-limit.ts`
**Outcome**: Changed rate limiter from IP-only keying to user-based with IP fallback. The `onBeforeHandle` hook now calls `auth().api.getSession()` to try to resolve the user — if authenticated, bucket key is `user:${userId}:${category}`, otherwise falls back to `ip:${clientIp}:${category}`. Session lookup is wrapped in try/catch so failures gracefully degrade to IP-based limiting. Extracted `getClientIp()` helper. All existing bucket categories unchanged (ingest: 10/min, chat: 30/min, crud: 100/min). Type checks pass.

## Task 5: Add request body size limit (API-2) ✅
**Files changed**: `apps/server/src/index.ts`
**Outcome**: Set `maxRequestBodySize: 2 * 1024 * 1024` (2MB) in the Elysia `.listen()` options. The default was 128MB which allowed arbitrarily large payloads. 2MB is sufficient for all JSON endpoints — this app doesn't handle file uploads (ingest takes URLs). Type checks pass.

## Task 6: Fix word quota race condition (SEC-2, DB-9) ✅
**Files changed**: `packages/api/src/modules/usage/service.ts`
**Outcome**: Replaced the CTE-based `reserveWords()` with a transaction + per-user advisory lock (`pg_advisory_xact_lock`). The old CTE had a race condition: when the row didn't exist yet, concurrent requests' `prev` CTEs both found no row to lock, so the ON CONFLICT path miscalculated `words_added` from a stale snapshot — allowing parallel requests to double-spend quota. The new approach: (1) acquires `pg_advisory_xact_lock(hashtext('usage:{userId}'))` to serialize all usage ops for a user, (2) reads current usage, (3) calculates exact available budget, (4) inserts or updates accordingly. Also wrapped `releaseWords()` in the same advisory lock pattern (DB-9) — prevents reserve/release interleaving for the same user. Removed unused `createId` import. Type checks pass.

## Task 7: Fix EventSource memory leak and add polling fallback (UX-1) ✅
**Files changed**: `apps/web/src/hooks/use-asset-events.ts`, `apps/web/src/components/library/asset-list.tsx`, `apps/web/src/components/asset/asset-shell.tsx`
**Outcome**: Moved SSE connection logic from a `useCallback` wrapper directly into the `useEffect` body — eliminates the unnecessary indirection. Added polling fallback: after 3 consecutive reconnect attempts at `MAX_RECONNECT_DELAY` (30s), the hook switches from SSE to polling via a new optional `onPollFallback` callback at 5-second intervals. If SSE recovers (via `onopen`), polling is stopped and counters reset. Both reconnect timeout and poll interval are cleaned up on unmount via the effect destructor. Updated both consumers — `asset-list.tsx` passes `loadAssets` as poll fallback, `asset-shell.tsx` passes a `refreshAsset` callback that refetches the single asset detail. Type checks pass.

